Index: player/SConscript
===================================================================
--- player/SConscript	(revision 7049)
+++ player/SConscript	(working copy)
@@ -1,7 +1,8 @@
 import os
 Import('env install_prefix sharedObjs subdirs')
 
-parseConfigs = ['pkg-config --cflags --libs playerc++']
+parseConfigs = ['pkg-config --cflags --libs playerc++',
+                'pkg-config --cflags --libs playerc']
 
 sources = ['GazeboDriver.cc',
            'GazeboClient.cc',
Index: libgazebo/SConscript
===================================================================
--- libgazebo/SConscript	(revision 7049)
+++ libgazebo/SConscript	(working copy)
@@ -20,6 +20,8 @@
 # setup a special build environment for libgazebo. Do this so we can control
 # what libgazebo depends upon
 #
+#  CC = '/opt/intel/cc/10.1.008/bin/icpc',
+#  CXX = '/opt/intel/cc/10.1.008/bin/icpc',
 env = Environment (
   CC = 'g++',
   CCFLAGS = Split ('-pthread -pipe  -W -Wall -O2'),
Index: libgazebo/gazebo.h
===================================================================
--- libgazebo/gazebo.h	(revision 7049)
+++ libgazebo/gazebo.h	(working copy)
@@ -556,7 +556,7 @@
 
 
 /// Maximum image pixels (width x height)
-#define GAZEBO_CAMERA_MAX_IMAGE_SIZE 640 * 480 * 3
+#define GAZEBO_CAMERA_MAX_IMAGE_SIZE 1024 * 1024 * 3
 
 /// \brief Camera interface data
 class CameraData
@@ -584,6 +584,9 @@
   /// Pose of the camera
   public: Pose camera_pose;
   
+  /// Is camera stream opened?
+  public: bool opened;
+  
 };
 
 /// \brief The camera interface
@@ -602,6 +605,7 @@
           {
             Iface::Create(server,id); 
             this->data = (CameraData*)this->mMap; 
+            this->data->opened=false;
           }
 
   /// \brief Open an existing interface
@@ -611,8 +615,18 @@
           {
             Iface::Open(client,id); 
             this->data = (CameraData*)this->mMap; 
+            this->data->opened=true;
           }
 
+  /// \brief Close an existing interface
+  /// \param client Pointer to the client
+  /// \param id Id of the interface
+  public: virtual void Close()
+          {
+            Iface::Close();
+            this->data->opened=false;
+          }
+
   /// Pointer to the camera data
   public: CameraData *data;
 };
@@ -851,6 +865,9 @@
 
   /// Commaned range count
   public: int cmd_range_count;
+
+  /// is laser interface opened?
+  public: bool opened;
 };
 
 /// \brief Laser interface
@@ -869,6 +886,7 @@
           {
             Iface::Create(server,id); 
             this->data = (LaserData*)this->mMap; 
+            this->data->opened=false;
           }
 
   /// \brief Open an existing interface
@@ -878,8 +896,16 @@
           {
             Iface::Open(client,id); 
             this->data = (LaserData*)this->mMap; 
+            this->data->opened=true;
           }
 
+  /// \brief Close an existing interface
+  public: virtual void Close()
+          {
+            Iface::Close();
+            this->data->opened=false;
+          }
+
   /// Pointer to the laser data
   public: LaserData *data;
 };
@@ -1083,6 +1109,30 @@
 
   /// Lift down flag
   public: int lift_down;
+
+  /// Enable flag
+  public: int cmdEnableMotor;
+
+  /// Gripper Position Rate Command
+  public: float cmdPositionRate;
+  /// Gripper Force Command
+  public: float cmdForce;
+  /// Gripper Gap Command
+  public: float cmdGap;
+
+  /// Gripper force
+  public: double gripperForce;
+  /// Gripper controller gains
+  public: double pGain;
+  public: double dGain;
+  public: double iGain;
+
+  /// Position
+  public: float actualFingerPosition[2];
+  /// Position Rate
+  public: float actualFingerPositionRate[2];
+
+
 };
 
 /// \brief Gripper interface
@@ -1280,6 +1330,8 @@
 /// \} */
 
 
+
+
 /***************************************************************************/
 /// \addtogroup libgazebo_iface
 /// \{
@@ -1360,7 +1412,7 @@
 \{
 */
 
-#define GAZEBO_STEREO_CAMERA_MAX_RGB_SIZE 640 * 480 * 3
+#define GAZEBO_STEREO_CAMERA_MAX_RGB_SIZE 640 * 480 * 9
 #define GAZEBO_STEREO_CAMERA_MAX_DISPARITY_SIZE 640 * 480
 
 /// \brief Stereo data
@@ -1398,6 +1450,9 @@
   /// Right depth map (float)
   public: float right_depth[GAZEBO_STEREO_CAMERA_MAX_DISPARITY_SIZE];
 
+  /// Is camera stream opened?
+  public: bool opened;
+  
 }; 
 
 
@@ -1415,6 +1470,7 @@
           {
             Iface::Create(server,id); 
             this->data = (StereoCameraData*)this->mMap; 
+            this->data->opened=false;
           }
 
   /// \brief Open the iface 
@@ -1422,8 +1478,16 @@
           {
             Iface::Open(client,id); 
             this->data = (StereoCameraData*)this->mMap; 
+            this->data->opened=true;
           }
 
+  /// \brief Close the iface 
+  public: virtual void Close()
+          {
+            Iface::Close();
+            this->data->opened=false;
+          }
+
   /// Pointer to the stereo data
   public: StereoCameraData *data;
 };
Index: server/physics/SphereGeom.cc
===================================================================
--- server/physics/SphereGeom.cc	(revision 7049)
+++ server/physics/SphereGeom.cc	(working copy)
@@ -66,11 +66,18 @@
   this->radiusP->SetValue( radius );
 
   // Initialize box mass matrix
-  dMassSetSphereTotal(&this->mass, this->massP->GetValue(), 
-                      this->radiusP->GetValue());
+  this->SetGeom( dCreateSphere(0, this->radiusP->GetValue()), true);
 
   // Create the sphere geometry
-  this->SetGeom( dCreateSphere(0, this->radiusP->GetValue()), true);
+  if (this->customMassMatrix)
+    dMassSetParameters(&this->mass, this->massP->GetValue(),
+           this->cx, this->cy, this->cz,
+           this->ixx,this->iyy,this->izz,
+           this->ixy,this->ixz,this->iyz);
+  else
+    dMassSetSphereTotal(&this->mass, this->massP->GetValue(), this->radiusP->GetValue());
+
+  
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: server/physics/BoxGeom.cc
===================================================================
--- server/physics/BoxGeom.cc	(revision 7049)
+++ server/physics/BoxGeom.cc	(working copy)
@@ -66,9 +66,18 @@
   this->sizeP->SetValue( size );
 
   // Initialize box mass matrix
-  dMassSetBoxTotal(&this->mass, this->massP->GetValue(), 
-      this->sizeP->GetValue().x, this->sizeP->GetValue().y, 
-      this->sizeP->GetValue().z);
+  // set mass matrix if user provides some info
+  // pending a tag <massMatrix>true</massMatrix> in geom:
+  if (this->customMassMatrix)
+    dMassSetParameters(&this->mass, this->massP->GetValue(),
+           this->cx, this->cy, this->cz,
+           this->ixx,this->iyy,this->izz,
+           this->ixy,this->ixz,this->iyz);
+  else
+    // Initialize box mass matrix
+    dMassSetBoxTotal(&this->mass, this->massP->GetValue(), 
+        this->sizeP->GetValue().x, this->sizeP->GetValue().y, 
+        this->sizeP->GetValue().z);
 
 
   // Create a box geometry with box mass matrix
Index: server/physics/Geom.hh
===================================================================
--- server/physics/Geom.hh	(revision 7049)
+++ server/physics/Geom.hh	(working copy)
@@ -188,6 +188,20 @@
     ///  Mass as a double
     protected: ParamT<double> *massP;
 
+    ///  User specified Mass Matrix
+    protected: ParamT<bool> *customMassMatrixP;
+    protected: ParamT<double> *cxP ;
+    protected: ParamT<double> *cyP ;
+    protected: ParamT<double> *czP ;
+    protected: ParamT<double> *ixxP;
+    protected: ParamT<double> *iyyP;
+    protected: ParamT<double> *izzP;
+    protected: ParamT<double> *ixyP;
+    protected: ParamT<double> *ixzP;
+    protected: ParamT<double> *iyzP;
+    protected: bool customMassMatrix;
+    protected: double cx,cy,cz,ixx,iyy,izz,ixy,ixz,iyz;
+
     private: ParamT<Vector3> *xyzP;
     private: ParamT<Quatern> *rpyP;
 
Index: server/physics/Body.hh
===================================================================
--- server/physics/Body.hh	(revision 7049)
+++ server/physics/Body.hh	(working copy)
@@ -101,6 +101,18 @@
     /// \return Rotation quaternion
     public: Quatern GetRotation() const;
   
+    /// \brief Return the velocity of the body
+    /// \return Velocity vector
+    public: Vector3 GetPositionRate() const;
+
+    /// \brief Return the rotation rates
+    /// \return Rotation Rate quaternion
+    public: Quatern GetRotationRate() const;
+
+    /// \brief Return the rotation rates
+    /// \return Rotation Rate Euler Angles RPY
+    public: Vector3 GetEulerRate() const;
+
     /// \brief Return the ID of this body
     /// \return ODE body id
     public: dBodyID GetId() const;
@@ -184,6 +196,7 @@
   
     private: ParamT<Vector3> *xyzP;
     private: ParamT<Quatern> *rpyP;
+    private: ParamT<bool> *turnGravityOffP;
   };
   
   /// \}
Index: server/physics/CylinderGeom.cc
===================================================================
--- server/physics/CylinderGeom.cc	(revision 7049)
+++ server/physics/CylinderGeom.cc	(working copy)
@@ -64,11 +64,21 @@
   this->sizeP->SetValue( size );
 
   // Initialize mass matrix
-  dMassSetCylinderTotal(&this->mass, this->massP->GetValue(), 3, 
-      this->sizeP->GetValue().x, this->sizeP->GetValue().y);
+  // pending a tag <massMatrix>true</massMatrix> in geom:
+  if (this->customMassMatrix)
+    dMassSetParameters(&this->mass, this->massP->GetValue(),
+           this->cx, this->cy, this->cz,
+           this->ixx,this->iyy,this->izz,
+           this->ixy,this->ixz,this->iyz);
+  else
+    // Initialize mass matrix
+    dMassSetCylinderTotal(&this->mass, this->massP->GetValue(), 3, 
+        this->sizeP->GetValue().x, this->sizeP->GetValue().y);
 
   this->SetGeom( dCreateCylinder( 0, this->sizeP->GetValue().x, 
         this->sizeP->GetValue().y ), true );
+
+
 }
 
 //////////////////////////////////////////////////////////////////////////////
Index: server/physics/Geom.cc
===================================================================
--- server/physics/Geom.cc	(revision 7049)
+++ server/physics/Geom.cc	(working copy)
@@ -73,6 +73,17 @@
 
   this->laserFiducialIdP = new ParamT<int>("laserFiducialId",-1,0);
   this->laserRetroP = new ParamT<float>("laserRetro",-1,0);
+
+  this->customMassMatrixP = new ParamT<bool>("massMatrix",false,0);
+  this->cxP = new ParamT<double>("cx",0.0,0);
+  this->cyP = new ParamT<double>("cy",0.0,0);
+  this->czP = new ParamT<double>("cz",0.0,0);
+  this->ixxP = new ParamT<double>("ixx",1e-6,0);
+  this->iyyP = new ParamT<double>("iyy",1e-6,0);
+  this->izzP = new ParamT<double>("izz",1e-6,0);
+  this->ixyP = new ParamT<double>("ixy",0.0,0);
+  this->ixzP = new ParamT<double>("ixz",0.0,0);
+  this->iyzP = new ParamT<double>("iyz",0.0,0);
   Param::End();
 }
 
@@ -99,6 +110,16 @@
   delete this->rpyP;
   delete this->laserFiducialIdP;
   delete this->laserRetroP;
+  delete this->customMassMatrixP;
+  delete this->cxP ;
+  delete this->cyP ;
+  delete this->czP ;
+  delete this->ixxP;
+  delete this->iyyP;
+  delete this->izzP;
+  delete this->ixyP;
+  delete this->ixzP;
+  delete this->iyzP;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -123,6 +144,63 @@
     this->massP->SetValue( 0.001 );
   }
 
+  this->customMassMatrixP->Load(node);
+  this->cxP ->Load(node);
+  this->cyP ->Load(node);
+  this->czP ->Load(node);
+  this->ixxP->Load(node);
+  this->iyyP->Load(node);
+  this->izzP->Load(node);
+  this->ixyP->Load(node);
+  this->ixzP->Load(node);
+  this->iyzP->Load(node);
+
+  // option to enter full maxx matrix
+  this->customMassMatrix = this->customMassMatrixP->GetValue();
+  this->cx  = this->cxP ->GetValue();
+  this->cy  = this->cyP ->GetValue();
+  this->cz  = this->czP ->GetValue();
+  this->ixx = this->ixxP->GetValue();
+  this->iyy = this->iyyP->GetValue();
+  this->izz = this->izzP->GetValue();
+  this->ixy = this->ixyP->GetValue();
+  this->ixz = this->ixzP->GetValue();
+  this->iyz = this->iyzP->GetValue();
+
+  // setup this->mass as well
+  this->mass.c[0] = this->cx;
+  this->mass.c[1] = this->cy;
+  this->mass.c[2] = this->cz;
+
+  this->mass.I[0] = this->ixx;
+  this->mass.I[1] = this->ixy;
+  this->mass.I[2] = this->ixz;
+
+  this->mass.I[3] = this->ixy;
+  this->mass.I[4] = this->iyy;
+  this->mass.I[5] = this->iyz;
+
+  this->mass.I[6] = this->ixz;
+  this->mass.I[7] = this->iyz;
+  this->mass.I[8] = this->izz;
+
+  this->mass.I[9] = 1;
+  this->mass.I[10] = 1;
+  this->mass.I[11] = 1;
+
+  // std::cout << " c[0] " << this->mass.c[0] << std::endl;
+  // std::cout << " c[1] " << this->mass.c[1] << std::endl;
+  // std::cout << " c[2] " << this->mass.c[2] << std::endl;
+  // std::cout << " I[0] " << this->mass.I[0] << std::endl;
+  // std::cout << " I[1] " << this->mass.I[1] << std::endl;
+  // std::cout << " I[2] " << this->mass.I[2] << std::endl;
+  // std::cout << " I[3] " << this->mass.I[3] << std::endl;
+  // std::cout << " I[4] " << this->mass.I[4] << std::endl;
+  // std::cout << " I[5] " << this->mass.I[5] << std::endl;
+  // std::cout << " I[6] " << this->mass.I[6] << std::endl;
+  // std::cout << " I[7] " << this->mass.I[7] << std::endl;
+  // std::cout << " I[8] " << this->mass.I[8] << std::endl;
+
   this->contact->Load(node);
 
   this->LoadChild(node);
@@ -396,23 +474,24 @@
   Pose3d pose;
   dQuaternion q;
   dMatrix3 r;
-  dMass bodyMass;
 
   if (!this->placeable)
     return NULL;
 
-  pose = this->GetPose();
+  pose = this->GetPose(); // get pose of the geometry
 
   q[0] = pose.rot.u;
   q[1] = pose.rot.x;
   q[2] = pose.rot.y;
   q[3] = pose.rot.z;
 
-  dQtoR(q,r);
+  dQtoR(q,r); // turn quaternion into rotation matrix
 
-
+  // this->mass was init to zero at start,
+  // read user specified mass into this->dblMass and dMassAdd in this->mass
   this->bodyMass = this->mass;
 
+
   if (dMassCheck(&this->bodyMass))
   {
     dMassRotate(&this->bodyMass, r);
Index: server/physics/Body.cc
===================================================================
--- server/physics/Body.cc	(revision 7049)
+++ server/physics/Body.cc	(working copy)
@@ -45,6 +45,10 @@
 #include "Geom.hh"
 #include "Body.hh"
 
+#ifdef TIMING
+#include "Simulator.hh"// for timing
+#endif
+
 using namespace gazebo;
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -70,6 +74,7 @@
 
   this->rpyP = new ParamT<Quatern>("rpy", Quatern(), 0);
   this->rpyP->Callback( &Body::SetRotation, this );
+  this->turnGravityOffP = new ParamT<bool>("turnGravityOff", false, 0);
   Param::End();
 }
 
@@ -107,6 +112,7 @@
   this->nameP->Load(node);
   this->xyzP->Load(node);
   this->rpyP->Load(node);
+  this->turnGravityOffP->Load(node);
   Pose3d initPose;
 
   initPose.pos = **(this->xyzP);
@@ -134,8 +140,9 @@
   }
 
   // If no geoms are attached, then don't let gravity affect the body.
-  if (this->geoms.size()==0)
+  if (this->turnGravityOffP->GetValue() || this->geoms.size()==0)
   {
+    std::cout << "setting gravity to zero for: " << this->nameP->GetValue() << std::endl;
     this->SetGravityMode(false);
   }
 
@@ -218,25 +225,51 @@
   std::vector< Sensor* >::iterator sensorIter;
   std::map< std::string, Geom* >::iterator geomIter;
 
+#ifdef TIMING
+  double tmpT1 = Simulator::Instance()->GetWallTime();
+#endif
+
   this->UpdatePose();
 
+#ifdef TIMING
+  double tmpT2 = Simulator::Instance()->GetWallTime();
+  std::cout << "           body Name (" << this->nameP->GetValue() << ")" << std::endl;
+  std::cout << "           UpdatePose dt (" << tmpT2-tmpT1 << ")" << std::endl;
+#endif
+
   if (!this->IsStatic())
   {
     // Set the pose of the scene node
     this->visualNode->SetPose(this->pose);
   }
 
+#ifdef TIMING
+  double tmpT3 = Simulator::Instance()->GetWallTime();
+  std::cout << "           Static SetPose dt (" << tmpT3-tmpT2 << ")" << std::endl;
+#endif
+
   for (geomIter=this->geoms.begin();
        geomIter!=this->geoms.end(); geomIter++)
   {
     geomIter->second->Update();
   }
 
+#ifdef TIMING
+  double tmpT4 = Simulator::Instance()->GetWallTime();
+  std::cout << "           Geom Update dt (" << tmpT4-tmpT3 << ")" << std::endl;
+#endif
+
   for (sensorIter=this->sensors.begin();
        sensorIter!=this->sensors.end(); sensorIter++)
   {
     (*sensorIter)->Update();
   }
+
+#ifdef TIMING
+  double tmpT5 = Simulator::Instance()->GetWallTime();
+  std::cout << "           sensors Update dt (" << tmpT5-tmpT4 << ")" << std::endl;
+#endif
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -404,6 +437,88 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+// Return the position of the body. in global CS
+Vector3 Body::GetPositionRate() const
+{
+  Vector3 vel;
+
+  if (this->bodyId)
+  {
+    const dReal *v;
+
+    v = dBodyGetLinearVel(this->bodyId);
+
+    vel.x = v[0];
+    vel.y = v[1];
+    vel.z = v[2];
+  }
+  else
+  {
+    vel.x = 0;
+    vel.y = 0;
+    vel.z = 0;
+  }
+
+  return vel;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+// Return the rotation
+Quatern Body::GetRotationRate() const
+{
+  Quatern velQ;
+  Vector3 vel;
+
+  if (this->bodyId)
+  {
+    const dReal *v;
+
+    v = dBodyGetAngularVel(this->bodyId);
+    vel.x = v[0];
+    vel.y = v[1];
+    vel.z = v[2];
+
+    velQ.SetFromEuler(vel);
+  }
+  else
+  {
+    vel.x = 0;
+    vel.y = 0;
+    vel.z = 0;
+    velQ.SetFromEuler(vel);
+  }
+
+  return velQ;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Return the rotation
+Vector3 Body::GetEulerRate() const
+{
+  Vector3 vel;
+
+  if (this->bodyId)
+  {
+    const dReal *v;
+
+    v = dBodyGetAngularVel(this->bodyId);
+    vel.x = v[0];
+    vel.y = v[1];
+    vel.z = v[2];
+
+  }
+  else
+  {
+    vel.x = 0;
+    vel.y = 0;
+    vel.z = 0;
+  }
+
+  return vel;
+}
+
+////////////////////////////////////////////////////////////////////////////////
 // Return the ID of this body
 dBodyID Body::GetId() const
 {
@@ -506,7 +621,6 @@
 void Body::UpdateCoM()
 {
   const dMass *lmass;
-  Pose3d oldPose, newPose, pose;
   std::map< std::string, Geom* >::iterator giter;
 
   if (!this->bodyId)
@@ -524,7 +638,13 @@
     }
   }
 
+  //return; // Stop pose update, we have full com xyz, I control
+
   // Old pose for the CoM
+  Pose3d oldPose, newPose, tmpPose;
+
+  // oldPose is the last comPose
+  // newPose is mass CoM
   oldPose = this->comPose;
 
   if (std::isnan(this->mass.c[0]))
@@ -546,19 +666,25 @@
   {
     if (giter->second->IsPlaceable())
     {
+      // FOR GEOMS:
+      // get pose with comPose set to oldPose
       this->comPose = oldPose;
-      pose = giter->second->GetPose();
+      tmpPose = giter->second->GetPose();
+
+      // get pose with comPose set to newPose
       this->comPose = newPose;
-      giter->second->SetPose(pose, false);
+      giter->second->SetPose(tmpPose, false);
     }
   }
 
 
-  // Fixup the pose of the CoM (ODE body)
+  // FOR BODY: Fixup the pose of the CoM (ODE body)
+  // get pose with comPose set to oldPose
   this->comPose = oldPose;
-  pose = this->GetPose();
+  tmpPose = this->GetPose();
+  // get pose with comPose set to newPose
   this->comPose = newPose;
-  this->SetPose(pose);
+  this->SetPose(tmpPose);
 
 
   // Settle on the new CoM pose
Index: server/physics/ode/ODEPhysics.hh
===================================================================
--- server/physics/ode/ODEPhysics.hh	(revision 7049)
+++ server/physics/ode/ODEPhysics.hh	(working copy)
@@ -133,6 +133,7 @@
 
   private: ParamT<double> *globalCFMP; 
   private: ParamT<double> *globalERPP; 
+  private: ParamT<bool> *quickStepP; 
 };
 
 /** \}*/
Index: server/physics/ode/ODEPhysics.cc
===================================================================
--- server/physics/ode/ODEPhysics.cc	(revision 7049)
+++ server/physics/ode/ODEPhysics.cc	(working copy)
@@ -44,6 +44,10 @@
 #include "XMLConfig.hh"
 #include "ODEPhysics.hh"
 
+#ifdef TIMING
+#include "Simulator.hh"// for timing
+#endif
+
 using namespace gazebo;
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -70,6 +74,7 @@
   Param::Begin(&this->parameters);
   this->globalCFMP = new ParamT<double>("cfm", 10e-5, 0);
   this->globalERPP = new ParamT<double>("erp", 0.2, 0);
+  this->quickStepP = new ParamT<bool>("quickStep", false, 0);
   Param::End();
 }
 
@@ -88,6 +93,7 @@
 
   delete this->globalCFMP;
   delete this->globalERPP;
+  delete this->quickStepP;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -103,6 +109,7 @@
   this->updateRateP->Load(cnode);
   this->globalCFMP->Load(cnode);
   this->globalERPP->Load(cnode);
+  this->quickStepP->Load(cnode);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -115,6 +122,7 @@
   stream << prefix << "  " << *(this->updateRateP) << "\n";
   stream << prefix << "  " << *(this->globalCFMP) << "\n";
   stream << prefix << "  " << *(this->globalERPP) << "\n";
+  stream << prefix << "  " << *(this->quickStepP) << "\n";
   stream << prefix << "</physics:ode>\n";
 }
 
@@ -133,13 +141,29 @@
 // Update the ODE engine
 void ODEPhysics::Update()
 {
+#ifdef TIMING
+  double tmpT1 = Simulator::Instance()->GetWallTime();
+#endif
+  
   // Do collision detection; this will add contacts to the contact group
   dSpaceCollide( this->spaceId, this, CollisionCallback );
 
+#ifdef TIMING
+  double tmpT2 = Simulator::Instance()->GetWallTime();
+  std::cout << "    collision dt (" << tmpT2-tmpT1 << ")" << std::endl;
+#endif
+
   // Update the dynamical model
-  dWorldStep( this->worldId, this->stepTimeP->GetValue() );
-  //dWorldQuickStep(this->worldId, this->stepTime);
+  if (this->quickStepP->GetValue())
+    dWorldQuickStep(this->worldId, this->stepTimeP->GetValue() );
+  else
+    dWorldStep( this->worldId, this->stepTimeP->GetValue() );
 
+#ifdef TIMING
+  double tmpT3 = Simulator::Instance()->GetWallTime();
+  std::cout << "    ode step dt (" << tmpT3-tmpT2 << ")" << std::endl;
+#endif
+
   // Very important to clear out the contact group
   dJointGroupEmpty( this->contactGroup );
 
@@ -266,15 +290,16 @@
         contact.surface.mode = dContactSlip1 | dContactSlip2 | 
                                dContactSoftERP | dContactSoftCFM |  
                                dContactBounce | dContactMu2 | dContactApprox1;
+        contact.surface.mode = 0;
 
 
         // Compute the CFM and ERP by assuming the two bodies form a
         // spring-damper system.
         h = self->stepTimeP->GetValue();
-        kp = 1 / (1 / geom1->contact->kp + 1 / geom2->contact->kp);
+        kp = 1.0 / (1.0 / geom1->contact->kp + 1.0 / geom2->contact->kp);
         kd = geom1->contact->kd + geom2->contact->kd;
         contact.surface.soft_erp = h * kp / (h * kp + kd);
-        contact.surface.soft_cfm = 1 / (h * kp + kd);
+        contact.surface.soft_cfm = 1.0 / (h * kp + kd);
 
         contact.surface.mu = MIN(geom1->contact->mu1, geom2->contact->mu1);
         contact.surface.mu2 = MIN(geom1->contact->mu2, geom2->contact->mu2);
Index: server/physics/TrimeshGeom.cc
===================================================================
--- server/physics/TrimeshGeom.cc	(revision 7049)
+++ server/physics/TrimeshGeom.cc	(working copy)
@@ -208,7 +208,13 @@
 
   this->geomId = dCreateTriMesh( this->spaceId, this->odeData,0,0,0 );
 
-  dMassSetTrimesh(&this->mass, this->massP->GetValue(), this->geomId);
+  if (this->customMassMatrix)
+    dMassSetParameters(&this->mass, this->massP->GetValue(),
+         this->cx, this->cy, this->cz,
+         this->ixx,this->iyy,this->izz,
+         this->ixy,this->ixz,this->iyz);
+  else
+    dMassSetTrimesh(&this->mass, this->massP->GetValue(), this->geomId);
 
   // Create the trimesh geometry
   this->SetGeom(this->geomId, true);
Index: server/sensors/Sensor.hh
===================================================================
--- server/sensors/Sensor.hh	(revision 7049)
+++ server/sensors/Sensor.hh	(working copy)
@@ -70,6 +70,7 @@
 
     /// \brief Set whether the sensor is active or not
     public: void SetActive(bool value);
+    public: bool IsActive();
 
     /// \brief  Load the child sensor
     protected: virtual void LoadChild(XMLConfigNode * /*node*/) {};
@@ -101,7 +102,6 @@
     protected: double lastUpdate;
     protected: std::string typeName;
   };
-  
   /// \}
 }
 #endif
Index: server/sensors/ray/RaySensor.hh
===================================================================
--- server/sensors/ray/RaySensor.hh	(revision 7049)
+++ server/sensors/ray/RaySensor.hh	(working copy)
@@ -100,6 +100,22 @@
   /// \return The number of ranges
   public: int GetRangeCount() const;
 
+  /// \brief Get the vertical scan line count
+  /// \return The number of scan lines vertically
+  public: int GetVerticalRayCount() const;
+
+  /// \brief Get the vertical scan line count
+  /// \return The number of scan lines vertically
+  public: int GetVerticalRangeCount() const;
+
+  /// \brief Get the vertical scan bottom angle
+  /// \return The minimum angle of the scan block
+  public: Angle GetVerticalMinAngle() const;
+
+  /// \brief Get the vertical scan line top angle
+  /// \return The Maximum angle of the scan block
+  public: Angle GetVerticalMaxAngle() const;
+
   /// \brief Set ray parameters
   /// \param index Rayindex (from 0 to rayCount - 1).
   /// \param a, b Ray endpoints (initial and final points).  These are
@@ -142,6 +158,11 @@
   /// Display rays when rendering images
   private: ParamT<bool> *displayRaysP;
 
+  // For ray blocks such as Velodyne
+  private: ParamT<int> *verticalRayCountP;
+  private: ParamT<int> *verticalRangeCountP;
+  private: ParamT<Angle> *verticalMinAngleP;
+  private: ParamT<Angle> *verticalMaxAngleP;
 };
 /// \}
 /// \}
Index: server/sensors/ray/RaySensor.cc
===================================================================
--- server/sensors/ray/RaySensor.cc	(revision 7049)
+++ server/sensors/ray/RaySensor.cc	(working copy)
@@ -64,6 +64,12 @@
   this->maxRangeP = new ParamT<double>("maxRange",0,1);
   this->originP = new ParamT<Vector3>("origin", Vector3(0,0,0), 0);
   this->displayRaysP = new ParamT<bool>("displayRays", true, 0);
+
+  // for block rays, vertical setting
+  this->verticalRayCountP = new ParamT<int>("verticalRayCount", 1, 0);
+  this->verticalRangeCountP = new ParamT<int>("verticalRangeCount", 1, 0);
+  this->verticalMinAngleP = new ParamT<Angle>("verticalMinAngle", DTOR(0), 0);
+  this->verticalMaxAngleP = new ParamT<Angle>("verticalMaxAngle", DTOR(0), 0);
   Param::End();
 }
 
@@ -80,6 +86,11 @@
   delete this->maxRangeP;
   delete this->originP;
   delete this->displayRaysP;
+
+  delete this->verticalRayCountP;
+  delete this->verticalRangeCountP;
+  delete this->verticalMinAngleP;
+  delete this->verticalMaxAngleP;
 }
 
 //////////////////////////////////////////////////////////////////////////////
@@ -99,6 +110,10 @@
   this->maxRangeP->Load(node);
   this->originP->Load(node);
   this->displayRaysP->Load(node);
+  this->verticalRayCountP->Load(node);
+  this->verticalRangeCountP->Load(node);
+  this->verticalMinAngleP->Load(node);
+  this->verticalMaxAngleP->Load(node);
 
 
   // Create a space to contain the ray space
@@ -128,6 +143,10 @@
   stream << prefix << "  " << *(this->rayCountP) << "\n";
   stream << prefix << "  " << *(this->rangeCountP) << "\n";
   stream << prefix << "  " << *(this->displayRaysP) << "\n";
+  stream << prefix << "  " << *(this->verticalRayCountP) << "\n";
+  stream << prefix << "  " << *(this->verticalRangeCountP) << "\n";
+  stream << prefix << "  " << *(this->verticalMinAngleP) << "\n";
+  stream << prefix << "  " << *(this->verticalMaxAngleP) << "\n";
 }
 
 //////////////////////////////////////////////////////////////////////////////
@@ -135,35 +154,42 @@
 void RaySensor::InitChild()
 {
   Pose3d bodyPose;
-  double angle;
+  double yawAngle, pitchAngle;
   Vector3 start, end, axis;
   RayGeom *ray;
 
   bodyPose = this->body->GetPose();
   this->prevPose = bodyPose;
 
+  double pDiff = (**(this->verticalMaxAngleP) - **(this->verticalMinAngleP)).GetAsRadian();
+  double yDiff = (**(this->maxAngleP) - **(this->minAngleP)).GetAsRadian();
   // Create and array of ray geoms
-  for (int i = 0; i < this->rayCountP->GetValue(); i++)
-  //for (int i = this->rayCount-1; i >= 0; i--)
+  for (int j = 0; j < this->verticalRayCountP->GetValue(); j++)
   {
-    double diff = (**(this->maxAngleP) - **(this->minAngleP)).GetAsRadian();
 
-    angle = i * diff / (rayCountP->GetValue() - 1) + (**(this->minAngleP)).GetAsRadian();
+    for (int i = 0; i < this->rayCountP->GetValue(); i++)
+    //for (int i = this->rayCount-1; i >= 0; i--)
+    {
 
-    axis.Set(cos(angle), sin(angle),0);
+      yawAngle = (rayCountP->GetValue() == 1)? 0 : i * yDiff / (rayCountP->GetValue() - 1) + (**(this->minAngleP)).GetAsRadian();
 
-    start = (axis * this->minRangeP->GetValue()) + this->originP->GetValue();
-    end = (axis * this->maxRangeP->GetValue()) + this->originP->GetValue();
+      pitchAngle = (verticalRayCountP->GetValue() == 1)? 0 :  j * pDiff / (verticalRayCountP->GetValue() - 1) + (**(this->verticalMinAngleP)).GetAsRadian();
 
-    ray = new RayGeom(this->body, displayRaysP->GetValue());
+      axis.Set(cos(pitchAngle)*cos(yawAngle), sin(yawAngle),sin(pitchAngle)*cos(yawAngle));
 
-    ray->SetPoints(start, end);
-//    ray->SetCategoryBits( GZ_LASER_COLLIDE );
-    //ray->SetCollideBits( ~GZ_LASER_COLLIDE );
+      start = (axis * this->minRangeP->GetValue()) + this->originP->GetValue();
+      end = (axis * this->maxRangeP->GetValue()) + this->originP->GetValue();
 
-    this->rays.push_back(ray);
+      ray = new RayGeom(this->body, displayRaysP->GetValue());
 
-    //this->body->AttachGeom(ray);
+      ray->SetPoints(start, end);
+      //ray->SetCategoryBits( GZ_LASER_COLLIDE );
+      //ray->SetCollideBits( ~GZ_LASER_COLLIDE );
+
+      this->rays.push_back(ray);
+
+      //this->body->AttachGeom(ray);
+    }
   }
 
 }
@@ -223,6 +249,34 @@
 }
 
 //////////////////////////////////////////////////////////////////////////////
+/// Get the vertical scan line count
+int RaySensor::GetVerticalRayCount() const
+{
+  return this->verticalRayCountP->GetValue();
+}
+
+//////////////////////////////////////////////////////////////////////////////
+/// Get the vertical scan line count
+int RaySensor::GetVerticalRangeCount() const
+{
+  return this->verticalRangeCountP->GetValue();
+}
+
+//////////////////////////////////////////////////////////////////////////////
+/// Get the vertical min angle
+Angle RaySensor::GetVerticalMinAngle() const
+{
+  return this->verticalMinAngleP->GetValue();
+}
+
+//////////////////////////////////////////////////////////////////////////////
+/// Get the vertical max angle
+Angle RaySensor::GetVerticalMaxAngle() const
+{
+  return this->verticalMaxAngleP->GetValue();
+}
+
+//////////////////////////////////////////////////////////////////////////////
 // Get detected range for a ray
 double RaySensor::GetRange(int index)
 {
Index: server/sensors/Sensor.cc
===================================================================
--- server/sensors/Sensor.cc	(revision 7049)
+++ server/sensors/Sensor.cc	(working copy)
@@ -33,6 +33,7 @@
 #include "ControllerFactory.hh"
 #include "Simulator.hh"
 #include "Sensor.hh"
+#include "Simulator.hh"
 
 using namespace gazebo;
 
@@ -71,6 +72,14 @@
 
   this->LoadController( node->GetChildByNSPrefix("controller") );
   this->LoadChild(node);
+
+  double updateRate  = node->GetDouble("updateRate", 0, 0);
+  if (updateRate == 0)
+    this->updatePeriod = 0.0; // no throttling if updateRate is 0
+  else
+    this->updatePeriod = 1.0 / updateRate;
+  this->lastUpdate   = Simulator::Instance()->GetSimTime();
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -185,4 +194,11 @@
   this->active = value;
 }
 
+////////////////////////////////////////////////////////////////////////////////
+/// \brief Set whether the sensor is active or not
+bool Sensor::IsActive()
+{
+  return this->active;
+}
 
+
Index: server/Global.hh
===================================================================
--- server/Global.hh	(revision 7049)
+++ server/Global.hh	(working copy)
@@ -88,4 +88,7 @@
 
 #define GZ_DELETE(p) { if(p) { delete (p);  (p)=NULL; } }
 
+// Timing Debug
+//#define TIMING
+
 #endif
Index: server/Simulator.cc
===================================================================
--- server/Simulator.cc	(revision 7049)
+++ server/Simulator.cc	(working copy)
@@ -74,6 +74,7 @@
   timeout(-1),
   selectedEntity(NULL)
 {
+  selectedEntity = NULL;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -293,6 +294,11 @@
   {
     currTime = this->GetRealTime();
 
+#ifdef TIMING
+    double tmpT1 = this->GetWallTime();
+    std::cout << "CURRENT simTime(" << this->simTime << ") current world time (" << tmpT1 << ")" << std::endl;
+#endif
+
     if (physicsUpdateRate == 0 || 
         currTime - this->prevPhysicsTime >= physicsUpdatePeriod) 
     {
@@ -317,6 +323,11 @@
       World::Instance()->Update();
     }
 
+#ifdef TIMING
+    double tmpT2 = this->GetWallTime();
+    std::cout << " World::Instance() TOTAL DT(" << tmpT2-tmpT1 << ")" << std::endl;
+#endif
+
     // Update the rendering
     if (renderUpdateRate == 0 || 
         currTime - this->prevRenderTime >= renderUpdatePeriod)
@@ -329,6 +340,10 @@
     if (this->gui)
     {
       this->gui->Update();
+#ifdef TIMING
+    double tmpT3 = this->GetWallTime();
+    std::cout << " GUI dt(" << tmpT3-tmpT2 << ")" << std::endl;
+#endif
     }
 
     elapsedTime = (this->GetRealTime() - currTime);
Index: server/XMLConfig.cc
===================================================================
--- server/XMLConfig.cc	(revision 7049)
+++ server/XMLConfig.cc	(working copy)
@@ -513,29 +513,59 @@
 ///////////////////////////////////////////////////////////////////////////
 // Get a file name.  Always returns an absolute path.  If the filename
 // is entered as a relative path, we prepend the world file path.
+// std::string XMLConfigNode::GetFilename( const std::string &key, const std::string &def, int require) const
+// {
+//   std::string filename = this->GetString( key, def, require );
+//
+//   if (filename.empty())
+//     return "";
+//
+//   if (filename[0] == '/' || filename[0] == '~')
+//     return filename;
+//   else
+//   {
+//     std::string result;
+//
+//     if (this->config->filename[0] != '/' && this->config->filename[0] != '~')
+//       result = "/";
+//
+//     unsigned int last = this->config->filename.rfind("/");
+//     if (last==0 || last+1 != this->config->filename.size())
+//       result += this->config->filename + "/" + filename;
+//     else
+//       result += this->config->filename.substr(0,last) + "/" + filename;
+//
+//     return result;
+//   }
+// }
+///////////////////////////////////////////////////////////////////////////
+// Get a file name.  Always returns an absolute path.  If the filename
+// is entered as a relative path, we prepend the world file path.
+//
+// patch by stu to do relative path.  FIXME: what was the original implementation that's broken?
+// sglaser: Was completely broken.  Now returns a path relative to the
+// (original) working directory.
 std::string XMLConfigNode::GetFilename( const std::string &key, const std::string &def, int require) const
 {
   std::string filename = this->GetString( key, def, require );
 
-  if (filename.empty())
-    return "";
+  if (filename.empty() && require)
+  {
+    gzthrow("unable to find required filename attribute[" << key << "] in world file node["
+            << this->GetName() << "]");
+  }
+  else if (filename.empty())
+    return def;
 
-  if (filename[0] == '/' || filename[0] == '~')
+  if (filename[0] == '/')
     return filename;
   else
   {
-    std::string result;
-
-    if (this->config->filename[0] != '/' && this->config->filename[0] != '~')
-      result = "/";
-
-    unsigned int last = this->config->filename.rfind("/");
-    if (last==0 || last+1 != this->config->filename.size())
-      result += this->config->filename + "/" + filename;
+    int last_slash = this->config->filename.rfind("/");
+    if (last_slash < 0)
+      return filename;
     else
-      result += this->config->filename.substr(0,last) + "/" + filename;
-
-    return result;
+      return this->config->filename.substr(0,last_slash) + "/" + filename;
   }
 }
 
Index: server/rendering/OgreCamera.cc
===================================================================
--- server/rendering/OgreCamera.cc	(revision 7049)
+++ server/rendering/OgreCamera.cc	(working copy)
@@ -66,8 +66,8 @@
   this->farClipP = new ParamT<double>("farClip",100,0);
   this->saveFramesP = new ParamT<bool>("saveFrames",false,0);
   this->savePathnameP = new ParamT<std::string>("saveFramePath","",0);
-  this->imageWidthP = new ParamT<unsigned int>("imageSize",640,0);
-  this->imageHeightP = new ParamT<unsigned int>("imageSize",480,0);
+  this->imageWidthP = new ParamT<unsigned int>("imageWidth",640,0);
+  this->imageHeightP = new ParamT<unsigned int>("imageHeight",480,0);
   this->visMaskP = new ParamT<std::string>("mask","none",0);
   this->hfovP = new ParamT<Angle>("hfov", Angle(DTOR(60)),0);
   Param::End();
Index: server/GazeboConfig.cc
===================================================================
--- server/GazeboConfig.cc	(revision 7049)
+++ server/GazeboConfig.cc	(working copy)
@@ -67,31 +67,34 @@
     this->gazeboPaths.push_back(gazebo_resource_path);
   }
 
-  // if both paths are set, don't check the config file or use the defaults.
-  if(ogre_resource_path && gazebo_resource_path) 
-    return;
-
-
   if (cfgFile)
   {
     XMLConfig rc;
     XMLConfigNode *node;
     rc.Load(rcFilename);
 
-    node = rc.GetRootNode()->GetChild("gazeboPath");
-    while (node)
+    // if gazebo path is set, skip reading from .gazeborc
+    if(!gazebo_resource_path)
     {
-      gzmsg(1) << "Gazebo Path[" << node->GetValue() << "]\n";
-      this->gazeboPaths.push_back(node->GetValue());
-      node = node->GetNext("gazeboPath");
+      node = rc.GetRootNode()->GetChild("gazeboPath");
+      while (node)
+      {
+        gzmsg(1) << "Gazebo Path[" << node->GetValue() << "]\n";
+        this->gazeboPaths.push_back(node->GetValue());
+        node = node->GetNext("gazeboPath");
+      }
     }
 
-    node = rc.GetRootNode()->GetChild("ogrePath");
-    while (node)
+    // if ogre path is set, skip reading from .gazeborc
+    if(!ogre_resource_path)
     {
-      gzmsg(1) << "Ogre Path[" << node->GetValue() << "]\n";
-      this->ogrePaths.push_back( node->GetValue() );
-      node = node->GetNext("ogrePath");
+      node = rc.GetRootNode()->GetChild("ogrePath");
+      while (node)
+      {
+        gzmsg(1) << "Ogre Path[" << node->GetValue() << "]\n";
+        this->ogrePaths.push_back( node->GetValue() );
+        node = node->GetNext("ogrePath");
+      }
     }
     this->RTTMode = rc.GetRootNode()->GetString("RTTMode", "PBuffer");
 
@@ -99,9 +102,18 @@
   else
   {
     gzmsg(0) << "Unable to find the file ~/.gazeborc. Using default paths. This may cause OGRE to fail.\n";
-    this->gazeboPaths.push_back("/usr/local/share/gazebo");
-    this->ogrePaths.push_back("/usr/local/lib/OGRE");
-    this->ogrePaths.push_back("/usr/lib/OGRE");
+
+    if ( !gazebo_resource_path )
+    {
+	this->gazeboPaths.push_back("/usr/local/share/gazebo");
+    }
+
+    if ( !ogre_resource_path )
+    {
+	this->ogrePaths.push_back("/usr/local/lib/OGRE");
+	this->ogrePaths.push_back("/usr/lib/OGRE");
+    }
+
     this->RTTMode="PBuffer";
   }
 }
Index: server/Model.cc
===================================================================
--- server/Model.cc	(revision 7049)
+++ server/Model.cc	(working copy)
@@ -47,6 +47,10 @@
 #include "IfaceFactory.hh"
 #include "Model.hh"
 
+#ifdef TIMING
+#include "Simulator.hh"// for timing
+#endif
+
 using namespace gazebo;
 
 uint Model::lightNumber = 0;
@@ -305,7 +309,7 @@
 
   return this->InitChild();
 }
-
+  
 ////////////////////////////////////////////////////////////////////////////////
 // Update the model
 int Model::Update()
@@ -316,6 +320,10 @@
 
   Pose3d bodyPose, newPose, oldPose;
 
+#ifdef TIMING
+  double tmpT1 = Simulator::Instance()->GetWallTime();
+#endif
+
   for (bodyIter=this->bodies.begin(); bodyIter!=this->bodies.end(); bodyIter++)
   {
     if (bodyIter->second)
@@ -324,6 +332,11 @@
     }
   }
 
+#ifdef TIMING
+  double tmpT2 = Simulator::Instance()->GetWallTime();
+  std::cout << "       bodies dt (" << tmpT2-tmpT1 << ")";
+#endif
+
   for (contIter=this->controllers.begin();
        contIter!=this->controllers.end(); contIter++)
   {
@@ -332,6 +345,11 @@
       contIter->second->Update();
   }
 
+#ifdef TIMING
+  double tmpT3 = Simulator::Instance()->GetWallTime();
+  std::cout << " controllers dt (" << tmpT3-tmpT2 << ")";
+#endif
+
   for (jointIter = this->joints.begin(); jointIter != this->joints.end(); jointIter++)
   {
     jointIter->second->Update();
@@ -350,6 +368,11 @@
     this->rpyP->SetValue(this->pose.rot);
   }
 
+#ifdef TIMING
+  double tmpT4 = Simulator::Instance()->GetWallTime();
+  std::cout << " joints/canonical body dt (" << tmpT4-tmpT3 << ")" << std::endl;
+#endif
+
   return this->UpdateChild();
 }
 
Index: server/gui/StatusBar.cc
===================================================================
--- server/gui/StatusBar.cc	(revision 7049)
+++ server/gui/StatusBar.cc	(working copy)
@@ -25,6 +25,7 @@
  */
 
 #include <stdio.h>
+#include <string.h>
 #include <FL/Fl_Value_Output.H>
 #include <FL/Fl_Output.H>
 #include <FL/Fl_Button.H>
Index: server/World.hh
===================================================================
--- server/World.hh	(revision 7049)
+++ server/World.hh	(working copy)
@@ -92,6 +92,26 @@
   /// \return Pointer to the physics engine
   public: PhysicsEngine *GetPhysicsEngine() const;
 
+  /// Get the simulation time
+  /// \return The simulation time
+  public: double GetSimTime() const;
+
+  /// Get the pause time
+  /// \return The pause time
+  public: double GetPauseTime() const;
+
+  /// Get the start time
+  /// \return The start time
+  public: double GetStartTime() const;
+
+  /// Get the real time (elapsed time)
+  /// \return The real time
+  public: double GetRealTime() const;
+
+  /// \brief Get the wall clock time
+  /// \return The wall clock time
+  public: double GetWallTime() const;
+
   /// \brief Load all entities
   /// \param node XMLConfg node pointer
   /// \param parent Parent of the model to load
@@ -186,6 +206,9 @@
   /// Simulation interface
   private: SimulationIface *simIface;
 
+  /// Current simulation time
+  private: double simTime, pauseTime, startTime;
+
   private: friend class DestroyerT<World>;
   private: friend class SingletonT<World>;
 };
Index: server/controllers/Controller.hh
===================================================================
--- server/controllers/Controller.hh	(revision 7049)
+++ server/controllers/Controller.hh	(working copy)
@@ -105,6 +105,9 @@
   /// \brief The entity that owns this controller
   protected: Entity *parent;
 
+  /// \breif flag to keep controllers updating continuously
+  protected: ParamT<bool> *alwaysOnP;
+
   /// \brief Update period 
   protected: double updatePeriod;
   protected: ParamT<double> *updatePeriodP;
Index: server/controllers/camera/generic/Generic_Camera.cc
===================================================================
--- server/controllers/camera/generic/Generic_Camera.cc	(revision 7049)
+++ server/controllers/camera/generic/Generic_Camera.cc	(working copy)
@@ -86,7 +86,24 @@
 // Update the controller
 void Generic_Camera::UpdateChild()
 {
-  this->PutCameraData();
+
+  // do this first so there's chance for sensor to run 1 frame after activate
+  if (this->myParent->IsActive())
+    this->PutCameraData();
+
+  // activate if iface open
+  if (this->cameraIface->Lock(1))
+  {
+    if (this->cameraIface->GetOpenCount() > 0)
+      this->myParent->SetActive(true);
+    else
+      this->myParent->SetActive(false);
+
+    //std::cout << " camera open count " << this->cameraIface->GetOpenCount() << std::endl;
+    this->cameraIface->Unlock();
+  }
+  //std::cout << " camera     active " << this->myParent->IsActive() << std::endl;
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: server/controllers/Controller.cc
===================================================================
--- server/controllers/Controller.cc	(revision 7049)
+++ server/controllers/Controller.cc	(working copy)
@@ -43,6 +43,7 @@
 {
   Param::Begin(&this->parameters);
   this->nameP = new ParamT<std::string>("name","",1);
+  this->alwaysOnP = new ParamT<bool>("alwaysOn", false, 0);
   this->updatePeriodP = new ParamT<double>("updateRate", 10, 0);
   Param::End();
 
@@ -60,6 +61,7 @@
 {
   this->Fini();
   delete this->nameP;
+  delete this->alwaysOnP;
   delete this->updatePeriodP;
 }
 
@@ -75,10 +77,17 @@
   this->typeName = node->GetName();
 
   this->nameP->Load(node);
+
+  this->alwaysOnP->Load(node);
+
   this->updatePeriodP->Load(node);
-  this->updatePeriod = 1.0 / (this->updatePeriodP->GetValue() + 1e-6);
 
-  this->lastUpdate = -1e6;
+  double updateRate  = this->updatePeriodP->GetValue();
+  if (updateRate == 0)
+    this->updatePeriod = 0.0; // no throttling if updateRate is 0
+  else
+    this->updatePeriod = 1.0 / updateRate;
+  this->lastUpdate   = Simulator::Instance()->GetSimTime();
 
   childNode = node->GetChildByNSPrefix("interface");
 
@@ -178,7 +187,7 @@
 /// Update the controller. Called every cycle.
 void Controller::Update()
 {
-  if (this->IsConnected())
+  if (this->IsConnected() || this->alwaysOnP->GetValue())
   {
     if (lastUpdate + updatePeriod <= Simulator::Instance()->GetSimTime())
     {
@@ -210,6 +219,10 @@
 {
   std::vector<Iface*>::const_iterator iter;
 
+  // if the alwaysOn flag is true, this controller is connected
+  if (this->alwaysOnP->GetValue())
+    return true;
+
   for (iter=this->ifaces.begin(); iter!=this->ifaces.end(); iter++)
   {
     if ((*iter)->GetOpenCount() > 0)
Index: server/controllers/ptz/generic/Generic_PTZ.cc
===================================================================
--- server/controllers/ptz/generic/Generic_PTZ.cc	(revision 7049)
+++ server/controllers/ptz/generic/Generic_PTZ.cc	(working copy)
@@ -70,10 +70,10 @@
 // Destructor
 Generic_PTZ::~Generic_PTZ()
 {
-  if (this->panJoint)
-    delete this->panJoint;
-  if (this->tiltJoint)
-    delete this->tiltJoint;
+  //if (this->panJoint)
+  //  delete this->panJoint;
+  //if (this->tiltJoint)
+  //  delete this->tiltJoint;
 
   this->panJoint = NULL;
   this->tiltJoint = NULL;
Index: server/World.cc
===================================================================
--- server/World.cc	(revision 7049)
+++ server/World.cc	(working copy)
@@ -27,6 +27,7 @@
 #include <assert.h>
 #include <sstream>
 #include <fstream>
+#include <sys/time.h> //gettimeofday
 
 #include "Global.hh"
 #include "GazeboError.hh"
@@ -57,6 +58,9 @@
   this->server = NULL;
   this->simIface = NULL;
 
+  this->simTime = 0.0;
+  this->pauseTime = 0.0;
+  this->startTime = 0.0;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -172,6 +176,7 @@
 
   this->physicsEngine->Init();
 
+  this->startTime = this->GetWallTime();
   this->toAddModels.clear();
   this->toDeleteModels.clear();
 
@@ -185,6 +190,12 @@
   std::vector< Model* >::iterator miter;
   std::vector< Model* >::iterator miter2;
 
+  this->simTime += this->physicsEngine->GetStepTime();
+
+#ifdef TIMING
+  double tmpT1 = this->GetWallTime();
+#endif
+
   // Update all the models
   for (miter=this->models.begin(); miter!=this->models.end(); miter++)
   {
@@ -194,14 +205,33 @@
     }
   }
 
+#ifdef TIMING
+  double tmpT2 = this->GetWallTime();
+  std::cout << " models update dt(" << tmpT2-tmpT1 << ")" << std::endl;
+#endif
+
   if (!Simulator::Instance()->IsPaused() &&
        Simulator::Instance()->GetPhysicsEnabled())
   {
     this->physicsEngine->Update();
   }
+  else
+  {
+    this->pauseTime += this->physicsEngine->GetStepTime();
+  }
 
+#ifdef TIMING
+  double tmpT3 = this->GetWallTime();
+  std::cout << " physics engine dt(" << tmpT3-tmpT2 << ")" << std::endl;
+#endif
+
   this->UpdateSimulationIface();
 
+#ifdef TIMING
+  double tmpT4 = this->GetWallTime();
+  std::cout << " sim Iface dt(" << tmpT4-tmpT3 << ")" << std::endl;
+#endif
+
   // Copy the newly created models into the main model vector
   std::copy(this->toAddModels.begin(), this->toAddModels.end(),
             std::back_inserter(this->models));
@@ -219,6 +249,11 @@
 
   this->toDeleteModels.clear();
 
+#ifdef TIMING
+  double tmpT5 = this->GetWallTime();
+  std::cout << " add/del models dt(" << tmpT5-tmpT4 << ")" << std::endl;
+#endif
+
   return 0;
 }
 
@@ -273,6 +308,41 @@
   return this->physicsEngine;
 }
 
+////////////////////////////////////////////////////////////////////////////////
+// Get the simulation time
+double World::GetSimTime() const
+{
+  return this->simTime;
+}
+////////////////////////////////////////////////////////////////////////////////
+// Get the pause time
+double World::GetPauseTime() const
+{
+  return this->pauseTime;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the start time
+double World::GetStartTime() const
+{
+  return this->startTime;
+}
+////////////////////////////////////////////////////////////////////////////////
+/// Get the real time (elapsed time)
+double World::GetRealTime() const
+{
+  return this->GetWallTime() - this->startTime;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the wall clock time
+double World::GetWallTime() const
+{
+  struct timeval tv;
+  gettimeofday(&tv, NULL);
+  return tv.tv_sec + tv.tv_usec * 1e-6;
+}
+
 ///////////////////////////////////////////////////////////////////////////////
 // Load a model
 int World::LoadEntities(XMLConfigNode *node, Model *parent)
Index: SConstruct
===================================================================
--- SConstruct	(revision 7049)
+++ SConstruct	(working copy)
@@ -22,8 +22,9 @@
 # 3rd party packages
 #
 parseConfigs=['pkg-config --cflags --libs OGRE',
+              'pkg-config --cflags --libs freeimage', 
+              'ode-config --cflags --libs', 
               'xml2-config --cflags --libs', 
-      	      'ode-config --cflags --libs',
               'fltk-config --cflags --libs --ldflags --use-gl --use-images',
               'pkg-config --cflags --libs xft'
               ]
@@ -31,6 +32,8 @@
 #
 # setup the build environment
 #
+#  CC = '/opt/intel/cc/10.1.008/bin/icc',
+#  CXX = '/opt/intel/cc/10.1.008/bin/icpc',
 env = Environment (
   CC = 'g++',
 
@@ -82,7 +85,7 @@
 rcconfig = env.RCConfig(target='gazeborc', source=Value(install_prefix))
 
 # DEFAULT list of subdirectories to build
-subdirs = ['libgazebo','server', 'player']
+subdirs = ['libgazebo','server']
 
 # Set the compile mode
 if env['mode'] == 'debug':
