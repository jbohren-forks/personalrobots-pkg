/**
 * Actions used to support testing. These actions utilize an explict specification of
 * a plan to decompose an action into its parts. This is mainly used for testing the indivudual
 * actions as directly as possible.
 */
class PlugActions extends AgentActions {

  /**
   * Super simple - detect outlet and move to position based on feedback
   */
  predicate DetectOutlet{}

  /**
   * Will execute actions as far as grapping the plug, and staging it, and then putting it back
   */
  predicate PickupAndRelease{}
};

PlugActions::DetectOutlet {
  // Tuck arms
  contains(safety_tuck_arms.Active cmd_tuck_arms);
  contains(detect_outlet_coarse.Active cmd_detect_outlet_coarse);
  //contains(move_base.Active cmd_move_base);

  // Sequence
  cmd_tuck_arms before cmd_detect_outlet_coarse;
  //cmd_detect_outlet_coarse before cmd_move_base;

  // Initial values in the base_footprint frame. Used to point the head
  eq(cmd_detect_outlet_coarse.frame_id, "base_footprint");
  eq(cmd_detect_outlet_coarse.x, 0.0);
  eq(cmd_detect_outlet_coarse.y, 0.0);
  eq(cmd_detect_outlet_coarse.z, 0.0);

  // Feedback paramater Bindings - obtain the point from the pose. The z value will be normal to the plug and we want to add the range
  any(detect_outlet_coarse.Inactive feedback_detect_outlet_coarse);
  cmd_detect_outlet_coarse meets feedback_detect_outlet_coarse;
  //eq(cmd_move_base.frame_id, feedback_detect_outlet_coarse.frame_id);
  //eq(cmd_move_base.time_stamp, feedback_detect_outlet_coarse.time_stamp);
  //eq(cmd_move_base.x, feedback_detect_outlet_coarse.x);
  //eq(cmd_move_base.y, feedback_detect_outlet_coarse.y);
  //eq(cmd_move_base.th, 0.0);

  concurrent(end, cmd_detect_outlet_coarse.end);
}

PlugActions::PickupAndRelease {
  // Subgoal all the actions. It would be nice if they were sequenced in declaration
  // These are variable declarations, in the form of contains(${X}.active cmd_${X})
  // where X is a variable declared in plugs/imports.nddl.
  contains(safety_tuck_arms.Active cmd_tuck_arms);
  contains(plugs_untuck_arms.Active cmd_untuck_arms);
  contains(detect_plug_on_base.Active cmd_detect_plug_on_base);
  contains(move_and_grasp_plug.Active cmd_move_and_grasp_plug);
  contains(detect_outlet_fine.Active cmd_detect_outlet_fine);
  contains(localize_plug_in_gripper.Active cmd_localize_plug_in_gripper);
  contains(stow_plug.Active cmd_stow_plug);

  // Sequence them
  cmd_tuck_arms before cmd_untuck_arms;
  cmd_untuck_arms before cmd_detect_plug_on_base;
  cmd_detect_plug_on_base before cmd_move_and_grasp_plug;
  cmd_move_and_grasp_plug before cmd_detect_outlet_fine;
  cmd_detect_outlet_fine before cmd_localize_plug_in_gripper;
  cmd_localize_plug_in_gripper before cmd_stow_plug;

  // Constrain all to be successful
  eq(SUCCESS,
     cmd_tuck_arms.status,
     cmd_untuck_arms.status,
     cmd_detect_plug_on_base.status,
     cmd_move_and_grasp_plug.status,
     cmd_stow_plug.status,
     cmd_detect_outlet_fine.status);

  // Bind parameters. Should be nice to say:
  // DetectPlugOnBase.Inactive feedback == detect_plug_on_base[cmd_detect_plug_on_base.end);
  // cmd_stow_plug.plug_state == feedback.plug_state
  any(detect_plug_on_base.Inactive feedback_detect_plug_on_base);
  cmd_detect_plug_on_base meets feedback_detect_plug_on_base;

  // Provides input to grasp
  eq_plug_stow_msg(cmd_move_and_grasp_plug.object, feedback_detect_plug_on_base.object);

  // Use a bogus point. Do we even need a point
  eq(cmd_detect_outlet_fine.time_stamp, feedback_detect_plug_on_base.time_stamp);
  eq(cmd_detect_outlet_fine.frame_id, "torso_lift_link");
  eq(cmd_detect_outlet_fine.x, 0.0);
  eq(cmd_detect_outlet_fine.y, 0.0);
  eq(cmd_detect_outlet_fine.z, 0.0);

  // Feedback from outlet detction used to target plug localization in the gripper
  any(detect_outlet_fine.Inactive feedback_detect_outlet_fine);
  cmd_detect_outlet_fine meets feedback_detect_outlet_fine;
  eq_pose_msg(feedback_detect_outlet_fine.object, cmd_localize_plug_in_gripper.object);

  // Stow it back where we got it
  eq_plug_stow_msg(cmd_stow_plug.object, feedback_detect_plug_on_base.object);

  // End the action when the last command finishes
  concurrent(end, cmd_stow_plug.end);
}

PlugActions plug_actions = new PlugActions();
