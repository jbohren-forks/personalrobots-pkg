/**
@mainpage

@htmlinclude manifest.html

Here are the gazebo plugins which are currently implemented:
 \li \ref gazebo::GazeboMechanismControl "ROS Mechanism Controls Plugin for MechanismControl"
 \li \ref gazebo::Ros_Time "ROS Time Plugin"
 \li \ref gazebo::Ros_Camera "ROS Camera Plugin"
 \li \ref gazebo::Ros_Laser "ROS Laser Scanner Plugin"
 \li \ref gazebo::Ros_Block_Laser "ROS Block Laser Scanner Plugin"
 \li \ref gazebo::Ros_PTZ "ROS PTZ Camera Plugin"
 \li \ref gazebo::P3D "ROS Ground Truth Broadcaster"


@section usage PR2 Simulation Quick Start Guide
\li If you have successfully \e rosmake \e 2dnav_gazebo, you have EVERYTHING and more needed to run all simulator+PR2 demos. Otherwise, to compile a minimum set of packages for running Gazebo:
  @verbatim
  $ rosmake gazebo
  $ rosmake gazebo_plugin
  $ rosmake gazebo_robot_description
  @endverbatim

\li Here is a simple launch script that starts Gazebo:
  @verbatim
  <launch>
    <!-- send pr2.xacro.xml to param server -->
    <param name="robotdesc/pr2" command="$(find xacro)/xacro.py '$(find pr2_defs)/robots/pr2.xacro.xml'" />

    <!-- start gazebo -->
    <node pkg="gazebo" type="gazebo" args="-n $(find gazebo_robot_description)/gazebo_worlds/simple.world" respawn="false" output="screen">
      <env name="LD_LIBRARY_PATH" value="$(find gazebo_plugin)/lib:$(find gazebo)/gazebo/lib:$(find Cg)/Cg/lib:$(optenv LD_LIBRARY_PATH)" />
      <env name="GAZEBO_RESOURCE_PATH" value="$(find gazebo_robot_description)/world" />
      <env name="OGRE_RESOURCE_PATH" value="$(find ogre)/ogre/lib/OGRE" />
      <env name="MC_RESOURCE_PATH" value="$(find gazebo_robot_description)/world" />
    </node>

    <!-- push robotdesc/pr2 to factory and spawn robot in gazebo -->
    <node pkg="gazebo_plugin" type="urdf2factory" args="robotdesc/pr2" respawn="false" output="screen" /> <!-- load default arm controller -->

    <!-- load controllers -->
    <include file="$(find pr2_gazebo)/pr2_default_controllers.launch" />
  </launch>
  @endverbatim
  see <a href="http://pr.willowgarage.com/wiki/roslaunch">roslaunch</a> for more details.

 - To start a mechanism::MechanismControlNode and spawn some controllers, you have to first send \b ros-pkg/robot_descrioption/pr2/pr2_defs/robots/pr2.xacro.xml to the parameter server, then invoke \b spawner.py with the controllers xml configuration file as the argument to spawn controllers:
  @verbatim
      <!-- send pr2.xacro.xml to parameter server as a string, allow retrieval by various components whe needs it
           (Mechanism Control, BaseControllerNode, etc...) -->
      <param name="robotdesc/pr2" command="$(find xacro)/xacro.py '$(find pr2_defs)/robots/pr2.xacro.xml'" />
      <!-- use spawner.py to spawn all controllers listed in controllers.xml -->
      <node pkg="mechanism_control" type="spawner.py" args="sp $(find pr2_default_controllers)/base_controller.xml" respawn="false" output="screen" />
  @endverbatim

 - The following \b control.py node sends a \e set_profile command of 0.5 to \b l_gripper_controller:
  @verbatim
    <!-- start arm controller -->
    <node pkg="mechanism_control" type="spawner.py" args="$(find arm_gazebo)/l_arm_default_controller.xml" respawn="false"  />
    <!-- send arm a command -->
    <node pkg="robot_mechanism_controllers" type="control.py" args="set l_gripper_controller 0.5" respawn="false" output="screen" />
  @endverbatim

\li Alternatively, one can start gazebo manually with an empty world (e.g. in bash):
  @verbatim
  $ export GAZ_TOP=`rospack find gazebo`/gazebo
  $ export OGRE_TOP=`rospack find ogre`/ogre
  $ export CG_TOP=`rospack find Cg`/Cg
  $ export SIM_PLUGIN=`rospack find gazebo_plugin`
  $ export PR2MEDIA=`rospack find gazebo_robot_description`/world
  $ export LD_LIBRARY_PATH=$SIM_PLUGIN/lib:$GAZ_TOP/lib:$CG_TOP/lib:$LD_LIBRARY_PATH
  $ export PATH=$GAZ_TOP/bin:$PATH
  $ export GAZEBO_RESOURCE_PATH=$PR2MEDIA
  $ export OGRE_RESOURCE_PATH=$OGRE_TOP/lib/OGRE
  $ export MC_RESOURCE_PATH=$PR2MEDIA
  $ gazebo `rospack find gazebo_robot_description`/gazebo_worlds/empty.world
  @endverbatim
  To spawn the robot in an empty world, first send robot XML to the parameter server:
  @verbatim
  $ roslaunch `rospack find pr2_full`/send_description.launch
  @endverbatim
  then call Gazebo factory spawner:
  @verbatim
  $ rosrun gazebo_plugin urdf2factory robotdesc/pr2
  @endverbatim


@section parameters Robot Descriptions
\li PR2 Robot Description
  Robot descriptions are explained in the <a href="http://pr.willowgarage.com/wiki/RobotDescriptionFormat">Robot Description Format</a> page.
  For example, you can find the complete PR2 description file in \b ros-pkg/robot_descriptions/pr2/pr2_defs/robots/pr2.xacro.xml.
  - To convert \b pr2.xacro.xml into Gazebo recognizable format run the following commands:
    @verbatim
    $ rosmake gazebo_plugin
    $ rosmake pr2_defs
    $ rosrun gazebo_plugin urdf2file `rospack find pr2_defs`/robots/pr2.expanded.xml `rospack find gazebo_robot_description`/world/pr2.model
    @endverbatim
    thus generating \b ros-pkg/robot_descriptions/gazebo_robot_description/world/pr2.model.

\li More Gazebo Examples:
    @verbatim
    $ rosmake examples_gazebo
    $ roslaunch `rospack find examples_gazebo`/single_link.launch
    or
    $ roslaunch `rospack find examples_gazebo`/dual_link.launch
    or
    $ roslaunch `rospack find examples_gazebo`/multi_link.launch
    @endverbatim
\li Arm Simulation Examples:
    @verbatim
    $ rosmake arm_gazebo
    $ roslaunch `rospack find arm_gazebo`/l_arm.launch
    or
    $ roslaunch `rospack find arm_gazebo`/r_arm.launch
    or
    $ roslaunch `rospack find arm_gazebo`/r_arm_grasping_demo.launch
    or
    $ roslaunch `rospack find arm_gazebo`/r_arm_spacenav.launch
    @endverbatim
\li PR2 Simulation Examples:
    @verbatim
    $ rosmake pr2_gazebo
    $ roslaunch `rospack find pr2_gazebo`/pr2_empty.launch
    or
    $ roslaunch `rospack find pr2_gazebo`/pr2_simple.launch
    or
    $ roslaunch `rospack find pr2_gazebo`/pr2_wg.launch
    or
    $ roslaunch `rospack find pr2_gazebo`/pr2_wg_no_x.launch
    @endverbatim
  
@section topic PR2 ROS topics
Various dynamically loaded plugins have been outfitted for PR2.
Below are the ROS messages actively used by PR2 simulation as described by launch script \b roslaunch \b ros-pkg/robot_descriptions/gazebo_robot_description/pr2_gazebo_actuators.xml.
Additional ROS topics and services used by PR2 simulation can be found in packages
 <a href="../../mechanism_control/html/index.html">             mechanism_control  </a>,
 <a href="../../robot_mechanism_controllers/html/index.html">   robot_mechanism_controllers </a> and
 <a href="../../pr2_mechanism_controllers/html/index.html">     pr2_mechanism_controllers </a>.

 - ROS topics published directly by the simulator plugins
     <table border="1">
     <tr><th>  Topic Name                          </th> <th> Message Type                         </th>  <th> Plugin Name             </th> <th>  Description                                               </th>  </tr>
     <tr><td> \b wrist_left/image                     </td> <td>  std_msgs::Image.msg                 </td>  <td>  Ros_Camera.hh          </td> <td>  Images from left wrist camera.                            </td>  </tr>
     <tr><td> \b wrist_right/image                    </td> <td>  std_msgs::Image.msg                 </td>  <td>  Ros_Camera.hh          </td> <td>  Images from right wrist camera.                           </td>  </tr>
     <tr><td> \b forearm_left/image                   </td> <td>  std_msgs::Image.msg                 </td>  <td>  Ros_Camera.hh          </td> <td>  Images from left forearm camera.                          </td>  </tr>
     <tr><td> \b forearm_right/image                  </td> <td>  std_msgs::Image.msg                 </td>  <td>  Ros_Camera.hh          </td> <td>  Images from right forearm camera.                         </td>  </tr>
     <tr><td> \b axis_right/image                     </td> <td>  std_msgs::Image.msg                 </td>  <td>  Ros_Camera.hh          </td> <td>  Images from left axis PTZ camera.                         </td>  </tr>
     <tr><td> \b axis_left/image                      </td> <td>  std_msgs::Image.msg                 </td>  <td>  Ros_Camera.hh          </td> <td>  Images from right axis PTZ camera.                        </td>  </tr>
     <tr><td> \b stereo_left/image                    </td> <td>  std_msgs::Image.msg                 </td>  <td>  Ros_Camera.hh          </td> <td>  Images from left stereo camera.                           </td>  </tr>

     <tr><td> \b base_scan                            </td> <td>  std_msgs::LaserScan.msg             </td>  <td>  Ros_Laser.hh           </td> <td>  Laser scans from Hokuyo at the base.                      </td>  </tr>
     <tr><td> \b tilt_scan                            </td> <td>  std_msgs::LaserScan.msg             </td>  <td>  Ros_Laser.hh           </td> <td>  Laser scans from tilting Hokuyo.                          </td>  </tr>

     <tr><td> \b full_cloud                           </td> <td>  std_msgs::PointCloud.msg     </td>  <td>  Ros_Block_Laser.hh     </td> <td>  Simulated point clouds data from stereo camera.           </td>  </tr>

     <tr><td> \b battery_state                        </td> <td>  robot_msgs::BatteryStzte            </td>  <td>  gazebo_battery.h       </td> <td> Simulated battery state.                                   </td>  </tr>
     <tr><td> \b diagnostic                           </td> <td>  robot_msgs::DiagnosticMessage       </td>  <td>  gazebo_battery.h       </td> <td> Simulated battery diagnostic messages.                     </td>  </tr>

     <tr><td> \b base_pose_ground_truth               </td> <td>  std_msgs::PoseWithRatesStamped      </td>  <td> P3D.hh                  </td> <td> Ground truth from the base, theoretical exact odometry.    </td>  </tr>
     <tr><td> \b gripper_roll_right_pose_ground_truth </td> <td>  std_msgs::PoseWithRatesStamped      </td>  <td> P3D.hh                  </td> <td> Ground truth from center of right gripper_roll link.       </td>  </tr>
     <tr><td> \b gripper_roll_left_pose_ground_truth  </td> <td>  std_msgs::PoseWithRatesStamped      </td>  <td> P3D.hh                  </td> <td> Ground truth from center of left gripper_roll link.        </td>  </tr>
     <tr><td> \b finger_tip_l_left_ground_truth       </td> <td>  std_msgs::PoseWithRatesStamped      </td>  <td> P3D.hh                  </td> <td> Ground truth from center of left finger tip on left arm.   </td>  </tr>
     <tr><td> \b finger_tip_r_left_ground_truth       </td> <td>  std_msgs::PoseWithRatesStamped      </td>  <td> P3D.hh                  </td> <td> Ground truth from center of right finger tip on left arm.  </td>  </tr>
     <tr><td> \b finger_tip_l_right_ground_truth      </td> <td>  std_msgs::PoseWithRatesStamped      </td>  <td> P3D.hh                  </td> <td> Ground truth from center of left finger tip on right arm.  </td>  </tr>
     <tr><td> \b finger_tip_R_right_ground_truth      </td> <td>  std_msgs::PoseWithRatesStamped      </td>  <td> P3D.hh                  </td> <td> Ground truth from center of right finger tip on right arm. </td>  </tr>
     <tr><td> \b axis_right/ptz_state                 </td> <td>  axis_cam::PTZActuatorState          </td>  <td> Ros_PTZ.hh              </td> <td> PTZ cameras actuator positions.                            </td>  </tr>
     <tr><td> \b axis_left/ptz_state                  </td> <td>  axis_cam::PTZActuatorState          </td>  <td> Ros_PTZ.hh              </td> <td> PTZ cameras actuator positions.                            </td>  </tr>
     <tr><td> \b time                                 </td> <td>  roslib::Time                      </td>  <td> Ros_Time.hh             </td> <td> Simulation time.                                           </td>  </tr>
     </table><br>
 - ROS topics subscribed by the simulator
     <table border="1">
     <tr><th>  Topic Name                          </th> <th> Message Type                         </th>  <th> Plugin Name             </th> <th>  Description                                               </th>  </tr>
     <tr><td> \e axis_left_ptz_cmd                 </td> <td>  axis_cam::PTZActuatorCmd            </td>  <td>  Ros_PTZ.hh             </td> <td>  Actuator commands for PTZ cameras.                        </td>  </tr>
     <tr><td> \e axis_right_ptz_cmd                </td> <td>  axis_cam::PTZActuatorCmd            </td>  <td>  Ros_PTZ.hh             </td> <td>  Actuator commands for PTZ cameras.                        </td>  </tr>
     </table><br>

@section param PR2 ROS Parameters
 - ROS parameters set by the simulator
     <table border="1">
     <tr><th>  Parameter Name                      </th> <th> Message Type                         </th>  <th> Plugin Name             </th> <th>  Description                                               </th>  </tr>
     <tr><td> \b full_charge_energy                </td> <td>  \e Float32                          </td>  <td>  gazebo_battery.h       </td> <td>  Battery state when fully charged in Joules.               </td>  </tr>
     </table><br>
 - ROS parameters read by the simulator
     <table border="1">
     <tr><th>  Parameter Name                      </th> <th> Message Type                         </th>  <th> Plugin Name             </th> <th>  Description                                               </th>  </tr>
     <tr><td> \e timeout                           </td> <td>  \e Float32                          </td>  <td>  gazebo_battery.h       </td> <td>  Timeout in seconds. (default=10.0sec)                     </td>  </tr>
     <tr><td> \e diagnostic_rate                   </td> <td>  \e Float32                          </td>  <td>  gazebo_battery.h       </td> <td>  Broadcast rate in Hz. (default=1.0 Hz)                    </td>  </tr>
     <tr><td> \e battery_state_rate                </td> <td>  \e Float32                          </td>  <td>  gazebo_battery.h       </td> <td>  Broadcast rate in Hz. (default=1.0 Hz)                    </td>  </tr>
     </table><br>

@section templates How To Construct Your Own ROS Gazebo Plugin
Here is a sample code for making a very simple plugin in Gazebo that publishes \c roslib::Time message over a ROS topic.
\li \b my_plugin.h:
@verbatim
#ifndef MY_PLUGIN_HH
#define MY_PLUGIN_HH

#include <gazebo/Controller.hh>
#include <gazebo/Body.hh>
#include <gazebo/World.hh>
#include <ros/node.h>
#include <roslib/Time.h>

namespace gazebo
{
  class my_plugin : public Controller
  {
    /// \brief Constructor
    /// \param parent The parent entity, must be a Model or a Sensor
    public: my_plugin(Entity *parent);

    /// \brief Destructor
    public: virtual ~my_plugin();

    /// \brief Load the controller
    /// \param node XML config node
    protected: virtual void LoadChild(XMLConfigNode *node);

    /// \brief Init the controller
    protected: virtual void InitChild();

    /// \brief Update the controller
    protected: virtual void UpdateChild();

    /// \brief Finalize the controller
    protected: virtual void FiniChild();

    /// \brief A mutex to lock access to fields that are used in message callbacks
    private: ros::thread::mutex lock_;
    /// \brief pointer to ROS node
    ros::node *rosnode_;
    roslib::Time my_message_;

    /// \brief For loading XML parameters
    private: ParamT<std::string> *my_topic_name_p_;

    /// \brief ROS topic name
    private:        std::string  *my_topic_name_;
  };
}
#endif
@endverbatim

\li \b my_plugin.cpp:
@verbatim
#include <gazebo/Global.hh>
#include <gazebo/XMLConfig.hh>
#include <gazebo/Simulator.hh>
#include <gazebo/gazebo.h>
#include <gazebo/GazeboError.hh>
#include <gazebo/ControllerFactory.hh>
#include <gazebo_plugin/my_plugin.h>

namespace gazebo {

  GZ_REGISTER_DYNAMIC_CONTROLLER("my_plugin", MyPlugin);

  ////////////////////////////////////////////////////////////////////////////////
  // Constructor
  MyPlugin::MyPlugin(Entity *parent)
      : Controller(parent)
  {

    // start a ROS node if it has not been started already
    rosnode_ = ros::g_node;
    int argc = 0;
    char** argv = NULL;
    if (rosnode_ == NULL)
    {
      ros::init(argc,argv);
      rosnode_ = new ros::node("ros_gazebo",ros::node::DONT_HANDLE_SIGINT);
      printf("-------------------- starting node in MyPlugin \n");
    }

    // Setup parameter loading from XML
    Param::Begin(&this->parameters);
    this->my_topic_name_p_ = new ParamT<std::string>("my_topicname","default_topic_name",0);
    Param::End();

  }

  ////////////////////////////////////////////////////////////////////////////////
  // Destructor
  MyPlugin::~MyPlugin()
  {
  }

  ////////////////////////////////////////////////////////////////////////////////
  // Load the controller
  void MyPlugin::LoadChild(XMLConfigNode *node)
  {
    // Load parameters from XML node
    this->my_topic_name_p_->Load(node);
    this->my_topic_name_ = this->my_topic_name_p_->GetValue();
  }

  ////////////////////////////////////////////////////////////////////////////////
  // Initialize the controller
  void MyPlugin::InitChild()
  {
    // Perform initializations
    rosnode_->advertise<roslib::Time>(this->my_topic_name_,10);
  }

  ////////////////////////////////////////////////////////////////////////////////
  // Update the controller
  void MyPlugin::UpdateChild()
  {
    // get time from simulator
    double current_time = Simulator::Instance()->GetSimTime();

    // publish time to ROS message
    this->lock_.lock();
    my_message_.rostime.sec  = (unsigned long)floor(current_time);
    my_message_.rostime.nsec = (unsigned long)floor(  1e9 * (  current_time - my_message_.rostime.sec) );
    rosnode_->publish(this->my_topic_name_,my_message_);
    this->lock_.unlock();
  }

  ////////////////////////////////////////////////////////////////////////////////
  // Finalize the controller
  void MyPlugin::FiniChild()
  {
    // unadvertise topic
    rosnode_->unadvertise(this->my_topic_name_);
  }
}


@endverbatim

\li The corresponding XML snippet required to setup the controller:
@verbatim
    <model:physical name="my_model">
      <controller:my_plugin name="my_plugin_name" plugin="libmy_plugin.so">
        <my_topicname>my_topic</my_topicname>
      </controller:my_plugin>
    </model:physical>
@endverbatim

**/
